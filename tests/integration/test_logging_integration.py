#!/usr/bin/env python3
"""
Integration test for the standardized logging system.

This test verifies that logs are correctly stored in the standardized location
when generated by modules that use the LoggingConfig system.
"""

import os
import sys
import unittest
import importlib.util
import shutil
from pathlib import Path

# Add the project root to the Python path to allow importing from core
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from core.logging.config import configure_logger
from core.logging.directory_manager import LogDirectoryManager, LOG_BASE_DIR


class LoggingIntegrationTest(unittest.TestCase):
    """Integration tests for the standardized logging system."""

    def setUp(self):
        """Set up the test environment."""
        # Create a backup of the existing logs directory if it exists
        self.log_base_dir = LOG_BASE_DIR
        self.backup_dir = f"{self.log_base_dir}_backup_test"
        
        if os.path.exists(self.log_base_dir):
            if os.path.exists(self.backup_dir):
                shutil.rmtree(self.backup_dir)
            shutil.copytree(self.log_base_dir, self.backup_dir)
            shutil.rmtree(self.log_base_dir)
        
        # Ensure the log directory exists
        os.makedirs(self.log_base_dir, exist_ok=True)
        
        # Test modules to verify
        self.test_modules = [
            "core_kg_conventions",
            "mcp_server",
            "automated_code_review"
        ]

    def tearDown(self):
        """Clean up after the test."""
        # Restore the original logs directory
        if os.path.exists(self.log_base_dir):
            shutil.rmtree(self.log_base_dir)
        
        if os.path.exists(self.backup_dir):
            shutil.copytree(self.backup_dir, self.log_base_dir)
            shutil.rmtree(self.backup_dir)

    def test_log_directory_creation(self):
        """Test that log directories are created for each module."""
        for module_name in self.test_modules:
            # Configure a logger for the module
            logger = configure_logger(module_name)
            
            # Generate some log messages
            logger.info(f"Integration test log message for {module_name}")
            logger.warning(f"Integration test warning for {module_name}")
            logger.error(f"Integration test error for {module_name}")
            
            # Check if the module log directory was created
            module_log_dir = os.path.join(self.log_base_dir, module_name)
            self.assertTrue(os.path.exists(module_log_dir), 
                           f"Log directory for {module_name} was not created")
            
            # Check if log files were created
            log_files = os.listdir(module_log_dir)
            self.assertTrue(len(log_files) > 0, 
                           f"No log files were created for {module_name}")
            
            # Check if log files contain the expected messages
            log_file_path = os.path.join(module_log_dir, log_files[0])
            with open(log_file_path, 'r') as f:
                log_content = f.read()
                self.assertIn(f"Integration test log message for {module_name}", log_content,
                             f"Log file for {module_name} does not contain expected message")

    def test_updated_modules_logging(self):
        """Test that updated modules correctly use the standardized logging system."""
        # Test core module
        try:
            # Import the module to trigger logging
            spec = importlib.util.spec_from_file_location(
                "record_conventions_creation",
                "core/kg/scripts/record_conventions_creation.py"
            )
            module = importlib.util.module_from_spec(spec)
            # Don't execute the module, just import it
            # spec.loader.exec_module(module)
            
            # Create a logger for the module to ensure the directory is created
            logger = configure_logger("core_kg_conventions")
            logger.info("Test message for core module")
            
            # Check if the log directory exists
            module_log_dir = os.path.join(self.log_base_dir, "core_kg_conventions")
            self.assertTrue(os.path.exists(module_log_dir),
                           "Log directory for core module was not created")
        except ImportError:
            self.fail("Failed to import core module for testing")
        
        # Test service module
        try:
            # Import the module to trigger logging
            spec = importlib.util.spec_from_file_location(
                "mcp_server",
                "services/mcp-server/src/mcp_server.py"
            )
            module = importlib.util.module_from_spec(spec)
            # Don't execute the module, just import it
            # spec.loader.exec_module(module)
            
            # Create a logger for the module to ensure the directory is created
            logger = configure_logger("mcp_server")
            logger.info("Test message for service module")
            
            # Check if the log directory exists
            module_log_dir = os.path.join(self.log_base_dir, "mcp_server")
            self.assertTrue(os.path.exists(module_log_dir),
                           "Log directory for service module was not created")
        except ImportError:
            self.fail("Failed to import service module for testing")
        
        # Test script module
        try:
            # Import the module to trigger logging
            spec = importlib.util.spec_from_file_location(
                "automated_code_review",
                "scripts/maintenance/automated_code_review.py"
            )
            module = importlib.util.module_from_spec(spec)
            # Don't execute the module, just import it
            # spec.loader.exec_module(module)
            
            # Create a logger for the module to ensure the directory is created
            logger = configure_logger("automated_code_review")
            logger.info("Test message for script module")
            
            # Check if the log directory exists
            module_log_dir = os.path.join(self.log_base_dir, "automated_code_review")
            self.assertTrue(os.path.exists(module_log_dir),
                           "Log directory for script module was not created")
        except ImportError:
            self.fail("Failed to import script module for testing")

    def test_log_file_naming_convention(self):
        """Test that log files follow the standardized naming convention."""
        for module_name in self.test_modules:
            # Configure a logger for the module
            logger = configure_logger(module_name)
            
            # Generate a log message
            logger.info(f"Testing log file naming for {module_name}")
            
            # Check if the module log directory was created
            module_log_dir = os.path.join(self.log_base_dir, module_name)
            self.assertTrue(os.path.exists(module_log_dir), 
                           f"Log directory for {module_name} was not created")
            
            # Check if log files follow the naming convention
            log_files = os.listdir(module_log_dir)
            self.assertTrue(len(log_files) > 0, 
                           f"No log files were created for {module_name}")
            
            # Check naming convention: YYYY-MM-DD_module-name-log
            import re
            pattern = r"\d{4}-\d{2}-\d{2}_" + module_name + r"-log"
            self.assertTrue(any(re.match(pattern, file) for file in log_files),
                           f"Log files for {module_name} do not follow the naming convention")

    def test_error_handling(self):
        """Test error handling for integration issues."""
        # Test with invalid module name (should still create directory)
        invalid_module = "invalid_module_name_for_testing"
        logger = configure_logger(invalid_module)
        logger.info("Test message for invalid module")
        
        module_log_dir = os.path.join(self.log_base_dir, invalid_module)
        self.assertTrue(os.path.exists(module_log_dir), 
                       "Log directory for invalid module was not created")
        
        # Test with permission issues (mock)
        # This is a simplified test - in a real environment, you would need to
        # mock permission errors or create a more sophisticated test
        original_makedirs = os.makedirs
        
        def mock_makedirs(*args, **kwargs):
            raise PermissionError("Mock permission error")
        
        try:
            # Replace os.makedirs with our mock
            os.makedirs = mock_makedirs
            
            # This should handle the permission error gracefully
            with self.assertRaises(PermissionError):
                LogDirectoryManager.create_log_directory("permission_test")
        finally:
            # Restore original function
            os.makedirs = original_makedirs


if __name__ == "__main__":
    unittest.main()